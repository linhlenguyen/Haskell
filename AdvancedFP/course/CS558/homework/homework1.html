
<title> CS558 Homework #1 </title>


<CENTER>
<BIG> CS558 Homework #1 </BIG> <BR>
Due 8:00 AM, Monday, Jan 11, 2016 <BR>
</CENTER>'

<p>

Homework must be submitted via D2L. All submitted files (five for this assignment) must be
submitted in the appropriate D2L directory in the drop box HW1. It is your responsibility to submit the homework in the proper
format. This format includes the following. Each file you submit should have the following information
on the first line as a comment (in the appropriate format for that kind of file).
This format is required for this homework, and all homework throughout the quarter.
<ol>
<li> Homework 1.
<li> Your name.
<li> Your email address.
</ol>
<p>
For example in a Haskell file
<PRE>
-- Homework 1  Tom Smith   tom_smith@gmail.com
</PRE>

or in a Python file
<PRE>
# Homework 1  Tom Smith   tom_smith@gmail.com
</PRE>

or in an *.e1 file
<PRE>
{- Homework 1  Tom Smith   tom_smith@gmail.com -}
</PRE>

<H3><B>Homework submitted without this information in the correct format will not be graded.</B></H3>

<p>
All programs mentioned can be downloaded from the this document
<ul>
<li> <A HREF="../code/hw1/Hw1A.py">Hw1A.py</A>
<li> <A HREF="../code/hw1/Hw1B.py">Hw1B.py</A>
<li> <A HREF="../code/hw1/Hw1A.hs">Hw1A.hs</A>
<li> <A HREF="../code/hw1/Hw1B.hs">Hw1B.hs</A>
<li> <A HREF="../code/hw1/Hw1Test1.e1">Hw1Test1.e1</A> a sample .e1 file.

</ul>


<H1>Purpose of this homework.</H1>

One of the goals of this course is for students to learn how to modify
programs in languages they are not familiar with. There are several things
that make this possible.
<ul>
  <li> Languages have similarities and features, so even if you are not familiar
       with something you might have seen something like it before.
  <li> By modifying code (rather than starting from scratch) we have code that we
       can study. Often needed changes are slight alterations or repetitions of code that is already
       there.
  <li> By running the code we can study the output, and make small changes to the program
       (perhaps printing small messages) that lets us discover what parts of the program
       produce which parts of the output.
  <li> Many languages have excellent tutorials. Find a tutorial and study the portion
       that relates to the changes you need to make.
  <li> Languages have standard libraries, and functions in these libraries can often
       be used to ge much of the effect needed.
</ul>

We also want you to learn how to install and use new languages.
This homework is meant to help you exercise these skills. You might want to
study the links on the <A HREF="../LanguageResources.html">language resource</A> page, install
both python and haskell on your machine, visit and try the languages on
the machnes in the linux labs, read a few tutorials, and discuss what you
have found with class mates. Remember, what you turn in must be your own work, that
you write up after your discussions.




<H1>Part A. Getting Started</H1> (try this now!).
<p>

Consider the programs Hw1A.py and Hw1A.hs. Each defines a function that takes
a string parameter "w" as input, and writes the string:  "Hello w!" to standard
output.

<p>
Each program can be
run within the language's interactive read-eval-print loop, by calling
"hi" with a string argument, or by executing the program from the command
line, where the first command line argument is used as the input to "hi".

<ul>
<li> for Python:
<ol>
<li> Using the python interpretor.
  <ul>
   <li> Start up python3.
   <li> load the file using <B>import Hw1A</B>.
   <li> Call the function "hi" by typing <B>Hw1A.hi("Steve")</B>.
   <li> Sample output <BR>
<B><PRE>
code> python3
Python 3.2.3 (default, Sep 25 2013, 18:22:43)
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import Hw1A
>>> Hw1A.hi("Steve")
Hello Steve!
</PRE></B>
    </ul>


<li> Use python on the command line.
   <ul>
     <li> Run python on the file by typing:  <B>python3 Hw1A.py Justin</B>
     <li> Sample output on Linux Lab machine<BR>
<B><PRE>
code> python3 Hw1A.py Justin
Hello Justin!
</PRE></B>

     <li> Sample output on my windows machine<BR>
<B><PRE>
code>python HW1A.py Sam
Hello Sam!
</PRE></B>
    <li>  Note the slight difference in how we access the python language! <p>
    </ul>

<li> Use the ability of Linux to implicitly call python3.
   <ul>
     <li> First change the files mode to executable by typing:  <B>chmod +X Hw1A.py</B>
     <li> Then just type the program name and its input on the command line: <B>./Hw1A.py Zane</B>
     <li> Sample output on Linux<BR>
<B><PRE>
code> chmod +X Hw1A.py
code> ./Hw1A.py Zane
Hello Zane!
</PRE></B>
    </ul>
</ol>

<li>
for Haskell:
<ol>
<li> Interpret Haskell using "ghci"
  <ul>
    <li> Start the interpretor from the command line using "ghci" and
         call the function "hi"
    <li> Sample ouput
  <PRE>
  code> ghci Hw1A.hs
  GHCi, version 7.4.1: http://www.haskell.org/ghc/  :? for help
  Loading package ghc-prim ... linking ... done.
  Loading package integer-gmp ... linking ... done.
  Loading package base ... linking ... done.
  Ok, modules loaded: Main.
  Prelude Main> hi "Bill"
  Hello Bill!
  </PRE>
  </ul>

<li> Run Haskell from command line using "runhaskell"
  <ul>
    <li> Use runhaskell on the command line,
          the second argument is used as the input to "hi"
    <li> Sample output
<Pre>
code> runhaskell Hw1a.hs Tommy
Hello Tommy!
</PRE>
    </ul>


<li> Compile program and then run compiled program from command line using "ghc"
   <ul>
      <li> Compile and run the executable.
           The first command line argument given to the compiled program
           is used as the input to "hi".

      <li> Sample output on Linux
<pre>
   code> ghc --make Hw1a.hs
   Linking Hw1a ...
   code> ./Hw1a Mary
   Hello Mary!
</pre>

   <li> Sample output on Windows (we need the extension ".exe" and don't need the "./"
<pre>
   code>ghc --make Hw1A.hs
   Linking Hw1A.exe ...
   code>Hw1A.exe Jane
   Hello Jane!
</pre>
   </ul>



</ol>
</ul>
You may use any of these methods when you run and test your code.

<p>

Your task is to alter each of these programs so that it reverses the characters in w before doing
its output.

<p>

For example, if the input string is <B>Andrew</B>, the output of the altered program should
be <B>Hello werdnA!</B>.

<p>

Programs should have a function "hi" with single string parameter "w" just as
before. Your extended programs should be called sol1A.py  and sol1A.hs Respectively.
(5 points each).

<p> <B>Hint:</B>
Before you try to take the string apart by hand, look at the functions available on strings and lists
in the standard libraries of the two languages.
Submit (just) the files sol1A.py and sol1A.hs.


<p>

<H1>Part B. The Expression Interpreter.</H1>
<p>
Consider a very simple language of expressions, which we'll call E1 Its abstract syntax is given
by the following tree grammar:

<pre>
Prog : Program -> Exp
Add : Exp -> Exp Exp
Sub : Exp -> Exp Exp
Mul : Exp -> Exp Exp
Div : Exp -> Exp Exp
Int : Exp -> (int)
</pre>
<p>
To actually read and write programs in the language, we'll use a LISP-style concrete syntax that
maps directly to the abstract syntax, specified by the following grammar:
<p>
<pre>
exp := int
     | '(' '+' exp exp ')'
     | '(' '-' exp exp ')'
     | '(' '*' exp exp ')'
     | '(' '/' exp exp ')'


int := digit
     | digit int
</pre>

This problem asks you to modify interpreters for E1, written in Python and Haskell, living in files called
Hw1B.py and Hw1B.hs.
respectively. These interpreters read a file containing an E1
program in the LISP-style concrete syntax described above and evaluate the expression, producing
an integer result.

<p>
The interpreters are primarily designed to be executed from the shell command
line, passing the filename to be interpreted as an command-line argument, e.g.,
<B>python3 Hw1B.py foo.e1</B> or <B>runhaskell Hw1B.hs foo.e1</B>.
<p>
It is also possible to execute the interpreters from within the read-eval-print loop, as
discussed in Part A of this assignment by starting the interpretor and then typing
<b>Interp.interp "foo.e1";;</b> in Python, or <b>interp "foo.e1"</b> in Haskell.
<p>
For example, if foo.e1 contains the following text:
<pre>
(/ {- Integer division rounds results down -}
(+ 7
(- 0 2)) {- Here's how to make a negative number -}
3)
</pre>
<p>
then both interpreters should return the answer
1.
<p>
Note that programs can be broken arbitrarily
across multiple lines. Any text within comment braces ( {- ... -} ) will be treated as a comment.
<p>
Here are your tasks:
 <ol>
    <li> Add a new feature to each interpreter: support for a remainder (
%
) operator. The relationship
of this operator to the existing operators is defined by the following equation:
(a/b)*b+(a%b) = a, for all and b, regardless of sign.
<p>
Notice that both Haskell and Python have a library function that implements
remainder (% in Python) (rem in Haskell), but they behave differently when given negative numbers,
but that should not stop you from implementing % as specified here.
<p>

Note: The Haskell version does not evaluate the program AST directly; instead, it compiles it
into a sequence of stack machine instructions, and then executes the resulting stack machine
program.
<p>

In adding support for the remainder operator, you must not change the instruction set or
implementation of the stack machine Implementation.

<p>

Hint: Look at the code for an existing binary operator, e.g., +. In the Python version, you need
to add a new class for % expressions. In the Haskell version, you will need to add a new
constructor to the Exp datatype and corresponding clauses to functions that match over that type
using case statements.

<p>
In each, you'll need to make two small additions to the lexer/parser.
<p>
Put your Python solution into a file
sol1B.py and put your Haskell solution into a file sol1B.hs.
<p>
Submit these two files. (30 points each).
<p>

Some hints about altering the Haskell program
<ul>
<li> Near line 42, you will need add a new constructor "Rem" to the datatype "exp" that describes expressions.
(Model your changes after "Add", "Sub", "Mul", and "Div").
<li> Near line 71, add a new clause to the function "exp_to_string"
so that it prints remainder expressions.
<li> Near line 155, add a clause to the function "compile"
that computes stack machine instructions from "Exp".
<li> Near line 170, add some code to parse remainder. You'll need 2 small changes here.
<li> You also might want to study the function "step" that executes the stack machine,
to help determine how to make additions to "compile".
</ul>
<p>

<li>  The Haskell version and the Python version of the compilers also behave differently on some programs
involving large integers. Find out what the differences are, and why they occur.
Write a single simple
program in the E1 language, that behaves differently under the two interpreters.
That is if you run the Python interpreter on the file, and you run the Haskell interpreter on the same file,
you get different answers.
Submit this program in a file sol1B.e1, which you submit
with the other files using D2L. This file must contain a comment
explaining the differences and the reasons for them. (Note: There are several
differences. Your sample program may illustrate only one of them, but your comment should
describe all that you find. (10 points for the program, 20 points for the comment).

</ol>