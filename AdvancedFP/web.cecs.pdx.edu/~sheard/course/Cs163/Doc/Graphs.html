<title>Graphs in Computer Science</title> <A NAME="WhatIsAGraph"></A>

<CENTER>
<BIG>Graphs in Computer Science</BIG>
</CENTER>
<p>
<HR ALIGN="center" WIDTH="100%">
<H2>Introduction</H2>
<p>
Graphs are mathematical concepts that have found many uses
in computer science. Graphs come in many different flavors, many of
which have found uses in computer programs. Some flavors are:
<ul>
<li> Simple graph
<li> Undirected or directed graphs
<li> Cyclic or acyclic graphs
<li> labeled graphs
<li> Weighted graphs
<li> Infinite graphs
<li> ... and many more too numerous to mention.
</ul>
<p>
Most graphs are defined as a slight alteration of the following
rules.
<p>
<ul>
<li> A graph is made up of two sets called Vertices and Edges.
<li> The Verticies are drawn from some underlying type, and the set may be finite or infinite.
<li> Each element of the Edge set is a pair consisting of two elements
   from the Vertices set.
<li> Graphs are often depicted visually, by drawing the elements
of the Vertices set as boxes or circles, and drawing the elements of the
edge set as lines or arcs between the boxes or circles. There is an arc
between v1 and v2 if (v1,v2) is an element of the Edge set.
</ul>
<p>
<B>Adjacency.</B> If (u,v) is in the edge set we say <B>u is adjacent to v</B>
(which we sometimes write as <B>u ~ v</B>).


<p>
For example the graph drawn below:
<p>
<A HREF=""><IMG SRC="../Graphics/graph1.png" ALT="?" BORDER=0></A>
<p>
Has the following parts.
<ul>
<li> The underlying set for the Verticies set is the integers.
<li> The Vertices set = {1,2,3,4,5,6}
<li> The Edge set = {(6,4),(4,5),(4,3),(3,2),(5,2),(2,1),(5,1)}
</ul>
<p>
<A NAME="KindsOfGraphs"></A>
<HR ALIGN="center" WIDTH="100%">
<H2>Kinds of Graphs </H2>

Various flavors of graphs have the following specializations
and particulars about how they are usually drawn.
<ul>
<li> <h3>Undirected Graphs.</H3> In an undirected graph, the order of the vertices in the pairs in the Edge set
doesn't matter. Thus, if we view the sample
graph above we could have written the Edge set as {(4,6),(4,5),(3,4),(3,2),(2,5)),(1,2)),(1,5)}.
Undirected graphs usually are drawn with straight lines between
the vertices.
<p>
The adjacency relation is symetric in an undirected graph, so if
<B>u ~ v</B> then it is also the case that <B>v ~ u</B>.

<li> <H3>Directed Graphs.</H3> In a directed graph the order
of the vertices in the pairs in the edge set matters. Thus
u is adjacent to v only if the pair (u,v) is in the Edge set.
For directed graphs we usually use arrows for the arcs between
vertices. An arrow from u to v is drawn only if (u,v) is in the Edge set.
The directed graph below
<p>
<A HREF=""><IMG SRC="../Graphics/graph2.jpg" ALT="?" BORDER=0></A>
<p>
Has the following parts.
<ul>
<li> The underlying set for the Verticies set is capital letters.
<li> The Vertices set = {A,B,C,D,E}
<li> The Edge set = {(A,B),(B,C),(D,C),(B,D),(D,B),(E,D),(B,E)}
</ul>
<p>
Note that both (B,D) and (D,B) are in the Edge set, so the
arc between B and D is an arrow in both directions.


<li> <H3>Vertex labeled Graphs.</H3> In a labeled graph, each vertex
is labeled with some data in addition to the data that identifies
the vertex. Only the indentifying data is present in the
pair in the Edge set. This is silliar to the (key,satellite) data
distinction for sorting.
<p>
<A HREF=""><IMG SRC="../Graphics/graph4.png" ALT="?" BORDER=0></A>
<p>
Here we have the following parts.
<ul>
<li> The underlying set for the keys of the Vertices set is the integers.
<li> The underlying set for the satellite data is Color.
<li> The Vertices set = {(2,Blue),(4,Blue),(5,Red),(7,Green),(6,Red),(3,Yellow)}
<li> The Edge set = {(2,4),(4,5),(5,7),(7,6),(6,2),(4,3),(3,7)}
</ul>
<p>
<li> <h3>Cyclic Graphs.</h3> A cyclic graph is a directed graph
with at least one cycle. A cycle is a path along the directed edges from a vertex to itself.
The vertex labeled graph above as several cycles.
One of them is 2 &raquo; 4 &raquo; 5 &raquo; 7 &raquo; 6 &raquo; 2

<li> <H3>Edge labeled Graphs.</h3> A Edge labeled graph is a
graph where the edges are associated with labels. One can indicate this be
making the Edge set be a set of triples. Thus if <B>(u,v,X)</B> is in
the edge set, then there is an edge from <B>u</B> to <B>v</B> with label <B>X</B>
<p>
Edge labeled graphs are usually drawn with the labels drawn adjacent to
the arcs specifying the edges.
<p>
<A HREF=""><IMG SRC="../Graphics/graph5.png" ALT="?" BORDER=0></A>
<p>
Here we have the following parts.
<ul>
<li> The underlying set for the the Vertices set is Color.
<li> The underlying set for the edge labels is sets of Color.
<li> The Vertices set = {Red,Green,Blue,White}
<li> The Edge set = {(red,white,{white,green})
                    ,(white,red,{blue})
                    ,(white,blue,{green,red})
                    ,(red,blue,{blue})
                    ,(green,red,{red,blue,white})
                    ,(blue,green,{white,green,red})}
</ul>
<p>

<li> <H3>Weighted Graphs.</h3> A weighted graph is an edge
labeled graph where the labels can be operated on by the
usual arithmetic operators, including comparisons like
using less than and greater than. In Haskell we'd say the
edge labels are i the Num class. Usually they are integers
or floats. The idea is that some edges may be more (or
less) expensive, and this cost is represented by the edge
labels or weight. In the graph below, which is an
undirected graph, the weights are drawn adjacent to the
edges and appear in dark purple.
<p>
<A HREF=""><IMG SRC="../Graphics/graph6.png" ALT="?" BORDER=0></A>
<p>
Here we have the following parts.
<ul>
<li> The underlying set for the the Vertices set is Integer.
<li> The underlying set for the weights is Integer.
<li> The Vertices set = {1,2,3,4,5}
<li> The Edge set = {(1,4,5)
                    ,(4,5,58)
                    ,(3,5,34)
                    ,(2,4,5)
                    ,(2,5,4)
                    ,(3,2,14)
                    ,(1,2,2)}
</ul>
<li> <H3>Directed Acyclic Graphs.</H3> A Dag is a directed graph
without cycles. They appear as special cases in CS applications all the time.
<p>
<A HREF=""><IMG SRC="../Graphics/graph7.png" ALT="?" BORDER=0></A>
<p>
Here we have the following parts.
<ul>
<li> The underlying set for the the Vertices set is Integer.
<li> The Vertices set = {1,2,3,4,5,6,7,8}
<li> The Edge set = {(1,7)
                    ,(2,6)
                    ,(3,1),(3,5)
                    ,(4,6)
                    ,(5,4),(5,2)
                    ,(6,8)
                    ,(7,2),(7,8)}
</ul>

<li> <H3>Disconnected Graphs</H3>
Vertices in a graph do not need to be connected to other vertices.
It is legal for a graph to have disconnected components, and even lone vertices
without a single connection.
<p>
<A HREF=""><IMG SRC="../Graphics/graph8.png" ALT="?" BORDER=0></A>
<p>
Vertices (like 5,7,and 8) with only <B>in-arrows</B> are called sinks.
Vertices with only <B>out-arrows</B> (like 3 and 4) are called sources.
<p>
Here we have the following parts.
<ul>
<li> The underlying set for the the Vertices set is Integer.
<li> The Vertices set = {1,2,3,4,5,6,7,8}
<li> The Edge set = {(1,7)
                    ,(3,1),(3,8)
                    ,(4,6)
                    ,(6,5)}
</ul>

</ul>
<p>
<HR ALIGN="center" WIDTH="100%"><A NAME="RepresentingGraphs"></A>
<H2>Representing graphs in a computer</H2>
<p>
Graphs are often used to represent physical entities
(a network of roads, the relationship between people, etc) inside
a computer. There are numerous mechansims used. <B>A good choice of
mechanism depends upon the operations that the computer program needs to perform on the graph
to acheive its needs</B>. Possible operations include.
<ul>
<li> Compute a list of all vertices
<li> Compute a list of all edges.
<li> For each vertex, <BIG>u</BIG>, compute a list of edges <BIG>(u,v)</BIG>.
This is often called the adjacency function.
<li> If the graph is labeled (either vertex labeled or edge labeled)
compute tha label for each vertex (or edge).
</ul>
<p>
Not all programs will need all of these operations, so for some
programs, an efficent representation that can compute only the
operations needed (but not the others), will suffice.
<p>
<ul>
<li> <H1>Graphs as sets.</H1> One way to represent graphs
would be to directly store the Vertices set and the Edge set. This
can make it difficult to efficiently compute adjacency
information for particular vertexes quickly, so this representation
is not used too often.

<li> <H1>Graphs as adjacency information.</H1> Most programs need
to compute all the vertices adjacent to a given vertex. This
corresponds to finding a 1-step path in the graph. In fact, for
many programs this is the only operation needed, so data structures
that support this operation quickly and efficiently are often used.
Possible choices include arrays, balanced trees, hash tables, etc.

<ol>
  <li> <H2>Graphs as functions.</H2> One useful abstraction is to
  think of the adjecency information as a function. Under this abstraction
  a graph is nothing more than a function.

  <pre>
  type Graph vertex = vertex -> [vertex]
  </pre>

  For example the undirected graph below:
  <p>
  <A HREF=""><IMG SRC="../Graphics/graph1.png" ALT="?" BORDER=0></A>
  <p>
  can be represented as the function.
  <pre>
  graph1::  Graph Int
  graph1 6 = [4]
  graph1 5 = [1,2,4]
  graph1 4 = [3,5,6]
  graph1 3 = [4,2]
  graph1 2 = [1,3,5]
  graph1 1 = [2,5]
  graph1 _ = []
  </pre>

  This mechansim can be extended to a wide variety of graphs types
  by slightly altering or enhancing the kind of function that represents
  the graph. Here are a few examples. <p>
  <ul>
    <li> <H3>Directed graph.</H3>
<pre>
  type Dgraph vertex = vertex -> [vertex]
</pre>

The representation is the same as a undirected graph
but the interpretation is different. In an undirected
graph, f, with edge (2,3), we would have both
<pre>
    f 2  --->  [3, ... ]
    f 3  --->  [2, ... ]
</pre>
but in a directed graph we would have only the first of the results.
Consider the directed graph below:
<p>
<A HREF=""><IMG SRC="../Graphics/graph2.jpg" ALT="?" BORDER=0></A>
<p>
We could represent this as a Dgraph as follows:
<pre>
data Node = A | B | C | D | E

graph2:: Dgraph Node
graph2 A = [B]
graph2 B = [C,D,E]
graph2 C = []
graph2 D = [B,C]
graph2 E = [D]
graph2 _ = []
</pre>

    <li> <H3>Vertex labeled graph.</H3>
<pre>
  type VLgraph label vertex = vertex -> ([vertex],label)
</pre>
Here the function not only returns the adjacency list for a vertex but also
the label. For example:
<p>
<A HREF=""><IMG SRC="../Graphics/graph4Small.png" ALT="?" BORDER=0></A>
<p>
<pre>
data Color = Blue | Red | Yellow | Green

graph4:: VLgraph Color Int
graph4 2 = ([4],Blue)
graph4 3 = ([7],Yellow)
graph4 4 = ([3,5],Blue)
graph4 5 = ([7],Red)
graph4 6 = ([2],Red)
graph4 7 = ([6],Green)
graph4 _ = ([],undefined)
</pre>


    <li> <H3>Edge labeled graph.</H3>
<pre>
  type ELgraph label vertex = vertex -> [(vertex,label)]
</pre>
Here, the adjency list now contains a tuple, the adjacent
vertex, and the label of the edge to that vertex.

<A HREF=""><IMG SRC="../Graphics/graph6.png" ALT="?" BORDER=0></A>

<pre>
graph6:: ELgraph Int Int
graph6 1 = [(4,5),(2,2)]
graph6 2 = [(1,2),(4,5),(3,14),(5,4)]
graph6 3 = [(2,14),(5,34)]
graph6 4 = [(1,5),(2,5),(5,58)]
graph6 5 = [(2,4),(3,34),(4,58)]
graph6 _ = []
</pre>


<li> <H3>DAG.</H3>
Here we have a simple graph, but the data must meet some invariants
ensuring no cycles.
<A HREF=""><IMG SRC="../Graphics/graph7.png" ALT="?" BORDER=0></A>
<pre>
graph7:: Graph Int
graph7 1 = [7]
graph7 2 = [6]
graph7 3 = [1,5]
graph7 4 = [6]
graph7 5 = [2,4]
graph7 6 = [8]
graph7 7 = [2,8]
graph7 8 = []
graph7 _ = []
</pre>

</ul>
</ul>

<H3>Advantages of representing graphs as functions</H3>
<ul>
<li> Simple and easy to understand
<li> Adapts easly to different kinds of graphs
</ul>
<H3>Disadvantages of using graphs as functions</H3>
<ul>
<li> Cannot be extended to accomodate queries about
the set of Vertices or the set of Edges.
<li> Depending upon the compiler that compiles the functions
may not be very efficient. In fact the worst case time could be proportional to the number of vertices.
<li> The graph must be known statically at compile time.


  </ul>

  <li> <H2>Graphs as arrays of adjacent vertexes.</H2>
One mechanism that can ameliorate the disadvantages of using functions
as a way to represent graphs is to use arrays instead. Using this
mechanism requires that the underlying domain of Vertices be some
type that can be used as indexes into an array.
<p>
In the rest of this note we will assume that Vertices are of type <B>Int</B>,
and that the Vertices set is a finite range of the type <B>Int</B>.
Thus a graph can be represented as follows:
<p>
<pre>
type ArrGraph = Array [Int]
</pre>
We can now answer a number queries about graphs quickly and efficiently.
<pre>
type ArrGraph i = Array [i]

vertices:: ArrGraph i -> IO[Int]
edges:: ArrGraph i -> IO[(Int,i)]
children:: ArrGraph i -> i -> IO[i]

vertices g =
  do { (lo,hi) <- boundsArr g
     ; return [lo..hi]}

edges g =
  do { (lo,hi) <- boundsArr g
     ; ees <- toListArr g
     ; return [ (i,j) | (i,cs) <- zip [lo..hi] ees, j <- cs ] }

children g node = readArr g node
</pre>

<H3>Advantages of representing graphs as arrays</H3>
<ul>
<li> Simple and easy to understand
<li> Efficient access
<li> Graphs can be constructed at run-time
<li> Adapts easly to different kinds of graphs
<pre>
type VLArrGraph label = Array ([Int],label)  -- Vertex labeled graphs
type ELArrGraph label = Array [(Int,label)]  -- Edge labeled graphs
</pre>
</ul>

<H3>Disadvantages of representing graphs as arrays</H3>
<ul>
<li> Requires that graph access be a Command rather than a computation.
<li> The domain of Vertices must be a type that can be used as an index into an array.
</ul>
</ol>
</ul>

<HR ALIGN="center" WIDTH="100%"> <A NAME="AlgorithmsOnGraphs"></A>
<H2>Algorithms on Graphs</H2>
<p>
There are many, many algorithms on graphs. In this note we will
look at a few of them. They include:
<ul>
<li> Searching Graphs
<li> Detecting Cycles in Graphs
<li> Shortest Path algorithms
</ul>
See the <A HREF="../Code/Graph.hs">code</A> for some examples.
<p>
<A HREF="../DailyRecord.html#Today">Back to the Daily Record.</A>
<p>
<A HREF="../index.html">Back to the class web-page.</A>
