<title>Datatypes, creating functions</title>

<CENTER>
<BIG>Datatypes, creating functions</BIG>
</CENTER>

<p>
In this homework you will gain skills by working
on two different tasks.
<ul>
<li> Creating and defining functions over user defined datatypes
<li> Creating functions in Haskell
</ul>
<p>

<H3>Part 1. Creating and defining functions over user defined data.</H3>
<p>
Study the notes we covered in class. This
includes the <A HREF="../Notes/DefiningNewDataTypes.pptx">presentation</A>
and the <A HREF="../Doc/DefiningNewData.hs">examples</A> we defined in class.
Then answer the following questions by writing a Haskell program.
<p>
A useful data type is called Maybe

<pre>
data Maybe a = Nothing | Just a
</pre>
<p>
It has two constructors <B>Nothing</B> and <B>Just</B>. It is often used when some input or result
is optional or may or may not be possible. Pattern matching will have two clauses.
For example a function that determines if the <B>Just</B> constructor is
used might look like:
<p>
<pre>
isJust Nothing = False
isJust (Just x) = True
</pre>
<p>

The maybe type is often used to indicate if something is possible.
For example when given a list of pairs, one might search for the
first pair where the first part of the pair is equal to some key,
and return <B>Just</B> the second part of the pair if a matching
pair is found. Note that sometimes no possible matching key is
found, so that is when the <B>Nothing</B> constructor is returned.
<p>
<STRONG>(1) Write the lookup function</STRONG> with contract
given below.

<p>
<pre>
find :: key -> [(key,value)] -> Maybe value
</pre>
Before you begin be sure you.
<ol>
<li> Create a bunch of examples using HUnit assertions
<li> Figure out how many cases there are. Ask yourself
do you case over the list or the Maybe type?
<li> How will you structure the comparison of the key.
Will you use guarded clauses? if expressions?
</ol>

<STRONG>(2) Write a data definition</STRONG> for a binary tree (i.e. branching trees have two branches).
There should be two non-branching constructors <B>Empty</B> which is a constant,
and <B>One</B> which stores a single element of any type. The <B>Branch</B> constructor
should have exactly two sub trees, and nothing else.
<pre>
data BinTree a = ...
</pre>
<p>
<STRONG>(3) Using the constructor functions of BinTree:
create 3 different trees of type <I>BinTree Int</I></STRONG>.
Recall the tree constructors are:
<B>Empty</B>, <B>One</B>, and <B>Branch</B>.
Be sure your trees vary in the number
of <I>Int</I> elements are stored in your three example trees.
<p>
<pre>
tree1,tree2,tree3:: BinTree Int
tree1 = undefined
tree2 = undefined
tree3 = undefined
</pre>
<p>
<STRONG>(4) Write two functions over BinTrees.</STRONG>
<p>
<pre>
flatten:: (BinTree a) -> [a]
</pre>
The idea is to create a list of all the elements of type <B>a</B> in
<B>BinTree a</B>.
<p>
and
<p>
<pre>
CountTree:: (BinTree Int) -> Int
</pre>
The idea is to sum up all the elemenets of type <B>Int</B> in
a <B>BintTree Int</B>. If no elements appear return zero.
<p>

Before you begin be sure you.
<ol>
<li> Create a bunch of examples using HUnit assertions
<li> Figure out how many cases there are.
<li> Think about how will you structure the patterns?
<li> What design recipes will you use?
<ul>
<li> <A HREF="../Doc/DesignRecipe.html">Generic program</A> design recipe.
<li> <A HREF="../Doc/RecursiveDesignRecipe.html">Recursive program</A> design recipe.
<li> <A HREF="../Doc/ArrayProcessingDeignRecipes.html">Array processing</A> design recipes.
</ul>
</ol>
<p>
<H3>Part 2. Creating functions in Haskell</H3>
<p>
Study the crib sheet <A HREF="../Haskell/Crib06.png">12 ways to create a function</A>.
Recall the source for this cribsheet can be found on the <A HREF="../Haskell/HaskellLinks.html">Haskell Resouce Sheet</A>.
<p>
(5) <STRONG>Write the function <I>plus5</I> three different ways</STRONG>. where (<B>plus5 3</B>) --> <B>8</B>,  (<B>plus5 0</B>) --> <B>5</B>, etc.
<ol>
<li> <pre> plus5a :: Int -> Int </pre>
     Using an anonymous function (lambda expression).
<li> <pre> plus5b :: Int -> Int </pre>
     Using a section.
<li> <pre> plus5c :: Int -> Int </pre>
     Using top level equations.
</ol>
<p>
<STRONG>(6) Write functions <I>smallest</I> and <I>largest</I> </STRONG>
(do not use the library functions <B>min</B> or <B>max</B>). Use
guarded clauses for <B>smallest</B> and an if expression for <B>largest</B>.
<p>
<pre>
smallest :: Ord t => t -> t -> t
largest  :: Ord t => t -> t -> t
</pre>
<p>
<STRONG>(7) Write the function <I>ncopies</I></STRONG>. Use a where clause and a comprehension.
<pre>
ncopies:: Int -> a -> [a]
</pre>

<HR ALIGN="center" WIDTH="100%">
<H3>What to turn in.</H3>
Get a copy of this worksheet (by right-clicking and the downloading)
and fill in the missing properties for each of the sorts.
<ul>
<li> Your name (as the author of the program) on the very first line
<li> Each of the properties filled in the apprpriate blank.
<li> The whole think uploaded to blackboard
<li> Due before class on Tuesday, October 20, 2009.
<li> You may cut and paste out the part of this document
not related to your answers (such as the list of properties
and the instructions of what to turn in).
</ul>


<p>
<A HREF="../DailyRecord.html#Today">Back to the Daily Record.</A>
<p>
<A HREF="../index.html">Back to the class web-page.</A>
